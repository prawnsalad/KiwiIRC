
/*!
 * Stylus - Node
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Evaluator = require('../visitor/evaluator')
  , utils = require('../utils')
  , nodes = require('./');

/**
 * Node constructor.
 *
 * @api public
 */

var Node = module.exports = function Node(){
  this.lineno = nodes.lineno;
  Object.defineProperty(this, 'filename', { value: nodes.filename });
  Object.defineProperty(this, 'source', { value: nodes.source });
};

/**
 * Return this node.
 *
 * @return {Node}
 * @api public
 */

Node.prototype.__defineGetter__('first', function(){
  return this;
});

/**
 * Return hash.
 *
 * @return {String}
 * @api public
 */

Node.prototype.__defineGetter__('hash', function(){
  return this.val;
});

/**
 * Return node name.
 *
 * @return {String}
 * @api public
 */

Node.prototype.__defineGetter__('nodeName', function(){
  return this.constructor.name.toLowerCase();
});

/**
 * Return this node.
 * 
 * @return {Node}
 * @api public
 */

Node.prototype.clone = function(){
  return this;
};

/**
 * Nodes by default evaluate to themselves.
 *
 * @return {Node}
 * @api public
 */

Node.prototype.eval = function(){
  return new Evaluator(this).evaluate();
};

/**
 * Return true.
 *
 * @return {Boolean}
 * @api public
 */

Node.prototype.toBoolean = function(){
  return nodes.true;
};

/**
 * Operate on `right` with the given `op`.
 *
 * @param {String} op
 * @param {Node} right
 * @return {Node}
 * @api public
 */

Node.prototype.operate = function(op, right){
  switch (op) {
    case 'is a':
      if ('string' == right.nodeName) {
        if ('color' == right.string) {
          return nodes.Boolean('rgba' == this.nodeName || 'hsla' == this.nodeName);
        } else {
          return nodes.Boolean(this.nodeName == right.val);
        }
      } else {
        throw new Error('"is a" expects a string, got ' + right.nodeName);
      }
    case '==':
      return nodes.Boolean(this.hash == right.hash);
    case '!=':
      return nodes.Boolean(this.hash != right.hash);
    case '>=':
      return nodes.Boolean(this.hash >= right.hash);
    case '<=':
      return nodes.Boolean(this.hash <= right.hash);
    case '>':
      return nodes.Boolean(this.hash > right.hash);
    case '<':
      return nodes.Boolean(this.hash < right.hash);
    case '||':
      return nodes.true == this.toBoolean()
        ? this
        : right;
    case 'in':
      var vals = utils.unwrap(right).nodes
        , hash = this.hash;
      if (!vals) throw new Error('"in" given invalid right-hand operand, expecting an expression');
      for (var i = 0, len = vals.length; i < len; ++i) {
        if (hash == vals[i].hash) {
          return nodes.true;
        }
      }
      return nodes.false;
    case '&&':
      var a = this.toBoolean()
        , b = right.toBoolean();
      return nodes.true == a && nodes.true == b
        ? right
        : nodes.false == a
          ? this
          : right;
    default:
      if ('[]' == op) {
        var msg = 'cannot perform '
          + this
          + '[' + right + ']';
      } else {
        var msg = 'cannot perform'
          + ' ' + this
          + ' ' + op
          + ' ' + right;
      }
      throw new Error(msg);
  }
};

/**
 * Default coercion throws.
 *
 * @param {Node} other
 * @return {Node}
 * @api public
 */

Node.prototype.coerce = function(other){
  if (other.nodeName == this.nodeName) return other;
  throw new Error('cannot coerce ' + other + ' to ' + this.nodeName);
};
